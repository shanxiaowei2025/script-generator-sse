import os
import io
from typing import List, Dict, Any
from reportlab.lib.pagesizes import A4
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib import colors
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Image, PageBreak, Table, TableStyle
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.lib.enums import TA_CENTER
from reportlab.pdfbase.cidfonts import UnicodeCIDFont
import re
from app.core.config import IMAGES_DIR
from PIL import Image as PILImage
import markdown
import html2text
from bs4 import BeautifulSoup

# 注册中文字体
try:
    # 尝试注册思源黑体 (Source Han Sans)
    font_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), '../static/fonts/SourceHanSansSC-Regular.otf')
    if os.path.exists(font_path):
        pdfmetrics.registerFont(TTFont('SourceHanSans', font_path))
        font_name = 'SourceHanSans'
    else:
        # 尝试注册系统中文字体
        if os.path.exists('/System/Library/Fonts/PingFang.ttc'):  # macOS
            pdfmetrics.registerFont(TTFont('PingFang', '/System/Library/Fonts/PingFang.ttc'))
            font_name = 'PingFang'
        elif os.path.exists('/usr/share/fonts/noto-cjk/NotoSansCJK-Regular.ttc'):  # Linux
            pdfmetrics.registerFont(TTFont('NotoSans', '/usr/share/fonts/noto-cjk/NotoSansCJK-Regular.ttc'))
            font_name = 'NotoSans'
        else:
            # 尝试使用ReportLab内置的中文字体
            try:
                pdfmetrics.registerFont(UnicodeCIDFont('STSong-Light'))
                font_name = 'STSong-Light'
            except:
                font_name = 'Helvetica'  # 默认回退
except Exception as e:
    print(f"字体注册失败: {str(e)}")
    font_name = 'Helvetica'  # 默认回退到无中文支持的字体

# 创建中文样式，确保编码支持
styles = getSampleStyleSheet()
styles.add(ParagraphStyle(
    name='ChineseTitle',
    fontName=font_name,
    fontSize=16,
    leading=20,
    alignment=TA_CENTER,  # 居中
    spaceAfter=12,
    encoding='utf-8'  # 明确指定UTF-8编码
))
styles.add(ParagraphStyle(
    name='ChineseHeading',
    fontName=font_name,
    fontSize=12,
    leading=16,
    spaceAfter=6,
    encoding='utf-8'  # 明确指定UTF-8编码
))
styles.add(ParagraphStyle(
    name='ChineseNormal',
    fontName=font_name,
    fontSize=10,
    leading=14,
    spaceBefore=2,
    spaceAfter=2,
    encoding='utf-8'  # 明确指定UTF-8编码
))
styles.add(ParagraphStyle(
    name='ChinesePrompt',
    fontName=font_name,
    fontSize=10,
    leading=14,
    leftIndent=10,
    textColor=colors.darkblue,
    encoding='utf-8'  # 明确指定UTF-8编码
))
styles.add(ParagraphStyle(
    name='WarningStyle',
    fontName=font_name,
    fontSize=10,
    leading=14,
    textColor=colors.red,
    encoding='utf-8'
))
styles.add(ParagraphStyle(
    name='WarningDetailStyle',
    fontName=font_name,
    fontSize=8,
    leading=12,
    textColor=colors.grey,
    encoding='utf-8'
))
styles.add(ParagraphStyle(
    name='ChineseScene',
    fontName=font_name,
    fontSize=12,
    leading=16,
    spaceAfter=6,
    bold=True,
    encoding='utf-8'  # 明确指定UTF-8编码
))
styles.add(ParagraphStyle(
    name='ChineseListItem',
    fontName=font_name,
    fontSize=10,
    leading=14,
    leftIndent=20,
    bulletIndent=10,
    spaceBefore=2,
    spaceAfter=2,
    encoding='utf-8'
))
styles.add(ParagraphStyle(
    name='ChineseLink',
    fontName=font_name,
    fontSize=10,
    leading=14,
    textColor=colors.blue,
    encoding='utf-8'
))
styles.add(ParagraphStyle(
    name='ChineseCodeBlock',
    fontName=font_name,
    fontSize=9,
    leading=12,
    leftIndent=20,
    rightIndent=20,
    backColor=colors.lightgrey,
    borderWidth=1,
    borderColor=colors.grey,
    borderPadding=5,
    spaceBefore=5,
    spaceAfter=5,
    encoding='utf-8'
))
styles.add(ParagraphStyle(
    name='TableCell',
    fontName=font_name,
    fontSize=9,
    leading=12,
    textColor=colors.black,
    encoding='utf-8'
))
styles.add(ParagraphStyle(
    name='TableHeader',
    fontName=font_name,
    fontSize=10,
    leading=14,
    alignment=1,  # 居中
    textColor=colors.black,
    encoding='utf-8'
))
styles.add(ParagraphStyle(
    name='TOC_Title',
    fontName=font_name,
    fontSize=14,
    leading=18,
    alignment=TA_CENTER,
    spaceAfter=10,
    encoding='utf-8'
))
styles.add(ParagraphStyle(
    name='TOC_Entry',
    fontName=font_name,
    fontSize=10,
    leading=14,
    spaceBefore=2,
    spaceAfter=2,
    encoding='utf-8'
))
styles.add(ParagraphStyle(
    name='TOC_Section',
    fontName=font_name,
    fontSize=12,
    leading=16,
    spaceBefore=6,
    spaceAfter=4,
    encoding='utf-8'
))

# 修改解析Markdown函数，增强表格处理能力
def parse_markdown(text):
    """将Markdown文本转换为HTML，支持表格等扩展功能"""
    # 预处理表格标记，确保能够正确识别
    if '|' in text:
        # 检查是否是表格行
        stripped = text.strip()
        if stripped.startswith('|') and stripped.endswith('|'):
            # 检查是否是虚线分隔行（表头和内容的分隔）
            if any(cell.strip().startswith('-') and set(cell.strip()) == {'-'} for cell in stripped.strip('|').split('|')):
                # 识别为分隔行，返回一个特殊标记的HTML，后续可以识别处理
                return '<table><tbody><tr class="separator-row"><td>SEPARATOR_ROW</td></tr></tbody></table>'
            # 其他普通表格行
            else:
                rows = []
                # 分割文本行
                cells = [cell.strip() for cell in stripped.strip('|').split('|')]
                # 创建表格HTML
                html_rows = '<tr>' + ''.join([f'<td>{cell}</td>' for cell in cells]) + '</tr>'
                table_html = f'<table><tbody>{html_rows}</tbody></table>'
                return table_html
            
    # 使用正常的markdown解析
    extensions = ['tables', 'fenced_code', 'codehilite']
    return markdown.markdown(text, extensions=extensions)

def html_to_plain(html):
    """将HTML转换为纯文本，保留基本格式"""
    h = html2text.HTML2Text()
    h.ignore_links = False
    h.body_width = 0  # 不自动换行
    return h.handle(html)

# 修改表格处理函数，改进单行表格的处理
def process_markdown_table(html_content):
    """从HTML中提取表格并转换为ReportLab的Table对象"""
    soup = BeautifulSoup(html_content, 'html.parser')
    tables = []
    
    for table_html in soup.find_all('table'):
        # 获取所有行
        rows = []
        
        # 检查是否有分隔行（特殊标记）
        separator_row = table_html.select_one('tr.separator-row')
        if separator_row and separator_row.get_text().strip() == 'SEPARATOR_ROW':
            # 这是一个分隔行，不添加内容，只在后续的表格样式中使用
            continue
        
        # 处理表头
        thead = table_html.find('thead')
        if thead:
            for tr in thead.find_all('tr'):
                row = []
                for th in tr.find_all(['th']):
                    row.append(Paragraph(th.get_text().strip(), ParagraphStyle(
                        name='TableHeader',
                        fontName=font_name,
                        fontSize=10,
                        leading=12,
                        alignment=1,  # 居中
                        textColor=colors.black,
                        encoding='utf-8'
                    )))
                if row:
                    rows.append(row)
        
        # 处理表格主体
        tbody = table_html.find('tbody')
        if tbody:
            for tr in tbody.find_all('tr'):
                # 跳过分隔行
                if 'separator-row' in tr.get('class', []):
                    continue
                    
                row = []
                for td in tr.find_all(['td']):
                    row.append(Paragraph(td.get_text().strip(), ParagraphStyle(
                        name='TableCell',
                        fontName=font_name,
                        fontSize=9,
                        leading=12,
                        encoding='utf-8'
                    )))
                if row:
                    rows.append(row)
        
        # 如果没有明确的thead或tbody，直接处理所有tr
        if not rows:
            for tr in table_html.find_all('tr'):
                # 跳过分隔行
                if 'separator-row' in tr.get('class', []):
                    continue
                    
                row = []
                for td in tr.find_all(['td', 'th']):
                    is_header = td.name == 'th'
                    style = ParagraphStyle(
                        name='TableHeader' if is_header else 'TableCell',
                        fontName=font_name,
                        fontSize=10 if is_header else 9,
                        leading=12,
                        alignment=1 if is_header else 0,  # 表头居中，单元格左对齐
                        textColor=colors.black,
                        encoding='utf-8'
                    )
                    row.append(Paragraph(td.get_text().strip(), style))
                if row:
                    rows.append(row)
        
        # 创建表格
        if rows:
            # 确保表格有内容
            if all(len(row) > 0 for row in rows):
                # 创建表格对象
                table = Table(rows)
                
                # 设置表格样式
                style = TableStyle([
                    ('BACKGROUND', (0, 0), (-1, 0), colors.lightgrey),  # 表头背景
                    ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),  # 表头文字颜色
                    ('ALIGN', (0, 0), (-1, 0), 'CENTER'),  # 表头居中
                    ('FONTNAME', (0, 0), (-1, 0), font_name),  # 表头字体
                    ('FONTSIZE', (0, 0), (-1, 0), 10),  # 表头字号
                    ('BOTTOMPADDING', (0, 0), (-1, 0), 6),  # 表头底部间距
                    ('BACKGROUND', (0, 1), (-1, -1), colors.white),  # 表格主体背景
                    ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),  # 表格主体文字颜色
                    ('ALIGN', (0, 1), (-1, -1), 'LEFT'),  # 表格主体左对齐
                    ('FONTNAME', (0, 1), (-1, -1), font_name),  # 表格主体字体
                    ('FONTSIZE', (0, 1), (-1, -1), 9),  # 表格主体字号
                    ('TOPPADDING', (0, 1), (-1, -1), 3),  # 表格主体顶部间距
                    ('BOTTOMPADDING', (0, 1), (-1, -1), 3),  # 表格主体底部间距
                    ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),  # 网格线
                    # 添加表头下方的粗分隔线
                    ('LINEBELOW', (0, 0), (-1, 0), 1.5, colors.black),  # 表头下方的粗线
                ])
                table.setStyle(style)
                tables.append(table)
    
    return tables

async def generate_script_pdf(
    script_content: str, 
    image_data: Dict[str, Dict[str, Dict[str, Dict[str, Any]]]], 
    output_path: str = None,
    task_id: str = None
) -> bytes:
    """
    生成包含剧本和图片的PDF文件
    
    Args:
        script_content: 剧本文本内容
        image_data: 包含图片相关信息的字典，格式为 {episode: {scene: {prompt_idx: {prompt}}}}
        output_path: 输出文件路径，不指定则返回PDF字节数据
        task_id: 任务ID，用于查找本地图片
        
    Returns:
        bytes: PDF文件的字节数据
    """
    # 确保script_content是UTF-8编码的字符串
    if isinstance(script_content, bytes):
        script_content = script_content.decode('utf-8')
    
    # 创建PDF文档
    buffer = io.BytesIO()
    doc = SimpleDocTemplate(
        buffer if output_path is None else output_path,
        pagesize=A4,
        rightMargin=72,
        leftMargin=72,
        topMargin=72,
        bottomMargin=72,
        encoding='utf-8'  # 明确指定UTF-8编码
    )
    
    # 存储PDF元素
    elements = []
    
    # 提取剧名
    title_match = re.search(r'《(.+?)》', script_content[:1000])
    title = f"《{title_match.group(1)}》" if title_match else "剧本"
    elements.append(Paragraph(f"{title} - 剧本与场景图", styles['ChineseTitle']))
    elements.append(Spacer(1, 0.25 * inch))
    
    # 创建目录项收集器
    toc_entries = []
    
    # 预处理：检测剧本中包含的集数
    all_episodes = set()
    episode_pattern = re.compile(r'第\s*(\d+)\s*集|^\s*(\d+)\s*集', re.MULTILINE)
    for match in episode_pattern.finditer(script_content):
        episode_num = match.group(1) if match.group(1) else match.group(2)
        all_episodes.add(episode_num)
    
    if all_episodes:
        print(f"预处理：检测到剧本中包含以下集数: {sorted(list(all_episodes))}")
    else:
        print("预处理：未检测到明确的集数标记")
    
    # 验证图片目录是否存在
    if task_id:
        image_dir = os.path.join(IMAGES_DIR, task_id)
        if not os.path.exists(image_dir):
            print(f"警告: 图片目录不存在: {image_dir}")
    else:
        print("警告: 未提供task_id，将无法找到本地图片")
        image_dir = None
    
    # 处理剧本内容
    lines = script_content.split('\n')
    current_episode = None
    current_scene = None
    # 修改场次格式正则表达式，使其更灵活匹配不同格式
    scene_format = re.compile(r'场次(\d+(?:-\d+)?)')
    episode_format = re.compile(r'第(\d+)集')
    
    # 代码块处理相关变量
    in_code_block = False
    code_block_lines = []
    code_block_language = ""
    
    # 表格处理相关变量
    in_table = False
    table_rows = []
    
    # 添加处理状态跟踪
    processed_episodes = set()
    processed_prompts = set()  # 添加已处理提示词的集合，避免重复处理
    
    # 遍历剧本的每一行
    i = 0
    skip_until_next_episode = False  # 添加标记变量，用于标记是否跳过当前集的剩余内容
    
    while i < len(lines):
        line = lines[i].strip()
        
        # 跳过空行，但在代码块和表格内不跳过
        if not line and not in_code_block and not in_table:
            i += 1
            continue
            
        # 如果当前在跳过模式，检查是否到了新的集
        if skip_until_next_episode:
            # 检查是否是新集的开始 - 增强匹配能力
            is_new_episode = False
            # 1. 标准格式: 第X集：标题
            if re.search(r'第\s*\d+\s*集[：:]\s*.*', line, re.IGNORECASE):
                is_new_episode = True
            # 2. 简单格式: 第X集
            elif re.search(r'^\s*第\s*\d+\s*集\s*$', line.strip(), re.IGNORECASE):
                is_new_episode = True
            # 3. 带标记格式: **第X集**或**第X集：标题**
            elif re.search(r'\*\*\s*第\s*\d+\s*集.*\*\*', line, re.IGNORECASE):
                is_new_episode = True
            # 4. 仅数字格式: 第X
            elif re.search(r'^\s*第\s*\d+\s*$', line.strip(), re.IGNORECASE):
                is_new_episode = True
            # 5. 数字+标题格式: 第X 标题
            elif re.search(r'^\s*第\s*\d+\s+\S', line.strip(), re.IGNORECASE):
                is_new_episode = True
            # 6. 直接数字格式: X集
            elif re.search(r'^\s*\d+\s*集', line.strip(), re.IGNORECASE):
                is_new_episode = True
                
            if is_new_episode:
                print(f"检测到新集开始: {line}")
                skip_until_next_episode = False  # 重置跳过标记
                # 不跳过这一行，继续正常处理
            else:
                i += 1  # 跳过这一行
                continue
            
        # 检测代码块开始和结束
        if line.startswith("```"):
            if not in_code_block:  # 代码块开始
                in_code_block = True
                code_block_lines = []
                # 提取语言信息
                code_block_language = line[3:].strip()
            else:  # 代码块结束
                in_code_block = False
                # 处理整个代码块
                if code_block_lines:
                    code_text = "\n".join(code_block_lines)
                    code_para = Paragraph(
                        f"<pre>{code_text}</pre>", 
                        styles['ChineseCodeBlock']
                    )
                    elements.append(code_para)
            i += 1
            continue
            
        # 在代码块内，收集代码行
        if in_code_block:
            code_block_lines.append(line)
            i += 1
            continue
            
        # 表格处理逻辑
        if '|' in line and line.strip().startswith('|') and line.strip().endswith('|'):
            # 如果这是第一行表格
            if not in_table:
                in_table = True
                table_rows = []
            
            # 检查是否是分隔行(全是连字符的行)
            is_separator_line = False
            cells = [cell.strip() for cell in line.strip().strip('|').split('|')]
            if cells and all(set(cell) == {'-'} for cell in cells if cell):
                is_separator_line = True
                # 如果已经有表头行，添加一条分隔线
                if table_rows:
                    # 不添加新行，但记录当前已经处理过分隔行
                    # 稍后在样式中添加粗分隔线
                    i += 1
                    continue
            
            # 解析普通表格行
            if not is_separator_line:
                # 将单元格转换为Paragraph对象
                row = [Paragraph(cell, styles['TableCell'] if table_rows else styles['TableHeader']) for cell in cells if cell]
                if row:
                    table_rows.append(row)
            
            # 检查下一行是否还是表格
            next_line_idx = i + 1
            if next_line_idx < len(lines):
                next_line = lines[next_line_idx].strip()
                # 如果下一行不是表格行或者是空行，结束表格处理
                if not next_line or not ('|' in next_line and next_line.startswith('|') and next_line.endswith('|')):
                    # 创建并添加表格
                    if table_rows:
                        table = Table(table_rows)
                        # 为表格添加样式
                        style = TableStyle([
                            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
                            ('FONTNAME', (0, 0), (-1, -1), font_name),
                            ('FONTSIZE', (0, 0), (-1, -1), 9),
                            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                            ('TOPPADDING', (0, 0), (-1, -1), 3),
                            ('BOTTOMPADDING', (0, 0), (-1, -1), 3),
                        ])
                        # 如果有表头（第一行）设置特殊样式
                        if len(table_rows) > 1:
                            style.add('BACKGROUND', (0, 0), (-1, 0), colors.lightgrey)
                            style.add('FONTSIZE', (0, 0), (-1, 0), 10)
                            style.add('ALIGN', (0, 0), (-1, 0), 'CENTER')
                            # 添加表头下方的粗分隔线
                            style.add('LINEBELOW', (0, 0), (-1, 0), 1.5, colors.black)
                        table.setStyle(style)
                        elements.append(table)
                        elements.append(Spacer(1, 0.1 * inch))
                    in_table = False
            
            i += 1
            continue
        
        # 如果之前在表格中，但当前行不是表格行，结束表格
        if in_table:
            # 创建并添加表格
            if table_rows:
                table = Table(table_rows)
                # 为表格添加样式
                style = TableStyle([
                    ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
                    ('FONTNAME', (0, 0), (-1, -1), font_name),
                    ('FONTSIZE', (0, 0), (-1, -1), 9),
                    ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                    ('TOPPADDING', (0, 0), (-1, -1), 3),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 3),
                ])
                # 如果有表头（第一行）设置特殊样式
                if len(table_rows) > 1:
                    style.add('BACKGROUND', (0, 0), (-1, 0), colors.lightgrey)
                    style.add('FONTSIZE', (0, 0), (-1, 0), 10)
                    style.add('ALIGN', (0, 0), (-1, 0), 'CENTER')
                    # 添加表头下方的粗分隔线
                    style.add('LINEBELOW', (0, 0), (-1, 0), 1.5, colors.black)
                table.setStyle(style)
                elements.append(table)
                elements.append(Spacer(1, 0.1 * inch))
            in_table = False
            
        # 匹配集数 - 增强识别能力
        if ('第' in line and '集' in line) or re.search(r'^\s*\d+\s*集', line.strip()):
            # 标准格式检查
            episode_found = False
            
            # 检查带有**标记的集标题
            if '**' in line:
                # 替换**标记为HTML粗体标签
                clean_line = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', line)
                # 提取集数
                episode_match = episode_format.search(clean_line) or re.search(r'第\s*(\d+)\s*集', clean_line)
                if episode_match:
                    current_episode = episode_match.group(1)
                    processed_episodes.add(current_episode)  # 记录处理的集数
                    episode_found = True
                    
                    # 添加目录项
                    toc_entry = f"第{current_episode}集"
                    toc_entries.append(("episode", toc_entry, len(elements) + 2))  # +2 因为会添加PageBreak和集标题
                    
                    elements.append(PageBreak())
                    elements.append(Paragraph(clean_line, styles['ChineseTitle']))
                    elements.append(Spacer(1, 0.1 * inch))
                    print(f"处理新集: 第{current_episode}集")
                    
                    # 每当进入新的集时，重置已处理提示词集合
                    processed_prompts = set()
            else:
                # 原来的处理逻辑
                episode_match = episode_format.search(line) or re.search(r'第\s*(\d+)\s*集', line)
                if episode_match:
                    current_episode = episode_match.group(1)
                    processed_episodes.add(current_episode)  # 记录处理的集数
                    episode_found = True
                    
                    # 添加目录项
                    toc_entry = f"第{current_episode}集"
                    toc_entries.append(("episode", toc_entry, len(elements) + 2))  # +2 因为会添加PageBreak和集标题
                    
                    elements.append(PageBreak())
                    elements.append(Paragraph(line, styles['ChineseTitle']))
                    elements.append(Spacer(1, 0.1 * inch))
                    print(f"处理新集: 第{current_episode}集")
                    
                    # 每当进入新的集时，重置已处理提示词集合
                    processed_prompts = set()
                # 处理直接数字格式: X集
                elif re.search(r'^\s*\d+\s*集', line.strip()):
                    current_episode = re.search(r'^\s*(\d+)\s*集', line.strip()).group(1)
                    processed_episodes.add(current_episode)  # 记录处理的集数
                    episode_found = True
                    
                    # 添加目录项
                    toc_entry = f"第{current_episode}集"
                    toc_entries.append(("episode", toc_entry, len(elements) + 2))  # +2 因为会添加PageBreak和集标题
                    
                    elements.append(PageBreak())
                    elements.append(Paragraph(line, styles['ChineseTitle']))
                    elements.append(Spacer(1, 0.1 * inch))
                    print(f"处理新集: 第{current_episode}集（数字格式）")
                    
                    # 每当进入新的集时，重置已处理提示词集合
                    processed_prompts = set()
            
            if episode_found:
                i += 1
                continue
        
        # 处理场次行
        elif line.strip().startswith('场次'):
            # 检查是否有粗体标记
            if '**' in line:
                # 替换星号为HTML粗体标签
                line = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', line)
                
            # 匹配场次
            scene_match = scene_format.search(line)
            if scene_match:
                current_scene = scene_match.group(1)
                # 记录场次
                # 添加目录项
                if current_episode:
                    toc_entry = f"场次{current_scene}"
                    toc_entries.append(("scene", toc_entry, len(elements)))
                
                elements.append(Paragraph(line, styles['ChineseScene']))
                print(f"识别到场次: {current_scene}")
            else:
                # 如果无法匹配场次格式，尝试从行中提取数字作为场次
                numbers = re.findall(r'\d+', line)
                if numbers:
                    current_scene = numbers[0]
                    if len(numbers) > 1:
                        # 如果有多个数字，尝试组合成类似"1-2"的格式
                        current_scene = f"{numbers[0]}-{numbers[1]}"
                    
                    # 添加目录项
                    if current_episode:
                        toc_entry = f"场次{current_scene}"
                        toc_entries.append(("scene", toc_entry, len(elements)))
                    
                    elements.append(Paragraph(line, styles['ChineseScene']))
                    print(f"从文本中提取场次: {current_scene}")
                else:
                    # 如果完全无法提取场次，使用默认格式
                    elements.append(Paragraph(line, styles['ChineseScene']))
                    print(f"无法识别场次格式: {line}")
            i += 1
            continue
        
        # 处理提示词（画面描述词）并直接显示其对应图片
        elif line.startswith('#'):
            # 添加提示词文本
            clean_prompt = line.replace('#', '').strip()
            if clean_prompt:
                # 生成提示词的唯一标识，避免重复处理
                prompt_key = f"{current_episode}_{current_scene}_{clean_prompt}"
                
                # 检查是否已处理过该提示词
                if prompt_key in processed_prompts:
                    print(f"跳过已处理的提示词: {prompt_key}")
                    i += 1
                    continue
                
                # 标记该提示词已处理
                processed_prompts.add(prompt_key)
                
                # 移除提示词显示
                # elements.append(Paragraph(f"提示词: {clean_prompt}", styles['ChinesePrompt']))
                
                # 如果当前已识别场次和集数，尝试查找对应图片
                if current_episode is not None and current_scene is not None:
                    # 新的提示词索引计算方法：基于当前场次
                    # 获取当前场次的所有提示词行
                    scene_lines = []
                    scene_start_index = 0
                    current_scene_found = False
                    
                    # 先找到当前场次的开始位置
                    for j in range(i-1, -1, -1):
                        if j < len(lines) and lines[j].strip().startswith('场次'):
                            scene_match = scene_format.search(lines[j].strip())
                            if scene_match and scene_match.group(1) == current_scene:
                                scene_start_index = j
                                current_scene_found = True
                                break
                            elif scene_match:  # 找到了前一个场次
                                break
                    
                    if current_scene_found:
                        # 计算从当前场次开始到当前行之间的提示词数量
                        prompt_count = 0
                        for j in range(scene_start_index, i+1):
                            if j < len(lines) and lines[j].strip().startswith('#'):
                                prompt_count += 1
                                if j == i:  # 这是当前提示词
                                    break
                        
                        # 当前提示词的索引 (从0开始)
                        prompt_idx = str(prompt_count - 1)  # 减1是因为我们要从0开始索引
                        print(f"场次 {current_scene} 的第 {prompt_idx} 个提示词")
                    else:
                        prompt_idx = "0"  # 默认为第一个提示词
                        print(f"无法确定场次 {current_scene} 的位置，使用默认提示词索引 0")
                    
                    # 尝试获取图片 - 改进的查找逻辑
                    image_paths = []
                    
                    if image_dir and os.path.exists(image_dir):
                        # 构建本地图片文件名格式
                        episode_formatted = f"第{current_episode}集"
                        scene_formatted = f"场次{current_scene}"
                        
                        # 1. 首先尝试精确匹配 - 当前提示词索引
                        images_found = False
                        for img_idx in range(4):  # 最多预期4张图片
                            local_img_path = os.path.join(
                                image_dir, 
                                f"{episode_formatted}_{scene_formatted}_{prompt_idx}_img{img_idx}.png"
                            )
                            if os.path.exists(local_img_path):
                                image_paths.append(local_img_path)
                                images_found = True
                                print(f"精确匹配，找到本地图片: {local_img_path}")
                        
                        # 2. 如果没有找到，尝试智能匹配 - 使用语义相似度查找
                        if not images_found:
                            # 存储所有候选图片组
                            candidate_groups = {}
                            
                            # 扫描目录中所有图片，找出当前场景的所有图片
                            scene_pattern = f"{episode_formatted}_{scene_formatted}_"
                            for filename in os.listdir(image_dir):
                                if filename.startswith(scene_pattern) and filename.endswith(".png"):
                                    # 从文件名提取索引信息
                                    try:
                                        # 格式: 第X集_场次Y-Z_索引_imgN.png
                                        parts = filename.split('_')
                                        if len(parts) >= 4:
                                            idx = parts[2]  # 提示词索引
                                            img_num = parts[3].split('.')[0].replace('img', '')
                                            
                                            if idx not in candidate_groups:
                                                candidate_groups[idx] = []
                                            
                                            candidate_groups[idx].append(os.path.join(image_dir, filename))
                                    except Exception as e:
                                        print(f"解析文件名失败: {filename}, 错误: {str(e)}")
                            
                            # 如果找到了候选组，选择最接近的一组
                            if candidate_groups:
                                # 如果有精确匹配的索引，直接使用
                                if prompt_idx in candidate_groups:
                                    image_paths = sorted(candidate_groups[prompt_idx])[:4]
                                    print(f"使用精确索引匹配图片组: {prompt_idx}")
                                else:
                                    # 否则，使用最接近的索引（数值上最接近）
                                    try:
                                        # 将所有索引转换为整数进行比较
                                        int_prompt_idx = int(prompt_idx)
                                        closest_idx = None
                                        min_diff = float('inf')
                                        
                                        for idx in candidate_groups.keys():
                                            try:
                                                int_idx = int(idx)
                                                diff = abs(int_idx - int_prompt_idx)
                                                if diff < min_diff:
                                                    min_diff = diff
                                                    closest_idx = idx
                                            except ValueError:
                                                continue
                                        
                                        if closest_idx is not None:
                                            image_paths = sorted(candidate_groups[closest_idx])[:4]
                                            print(f"使用最接近的索引匹配图片组: {closest_idx}，原索引: {prompt_idx}")
                                    except ValueError:
                                        # 如果转换失败，随机选择一组
                                        random_idx = list(candidate_groups.keys())[0]
                                        image_paths = sorted(candidate_groups[random_idx])[:4]
                                        print(f"无法比较索引，随机选择图片组: {random_idx}")
                        
                    # 如果成功找到图片，创建一个图片表格
                    if image_paths:
                        max_width = 2.0 * inch  # 每张图片的最大宽度
                        max_height = 2.0 * inch  # 每张图片的最大高度
                        img_objs = []
                        
                        for img_path in image_paths:
                            try:
                                # 使用PIL打开图片获取原始尺寸
                                pil_img = PILImage.open(img_path)
                                img_w, img_h = pil_img.size
                                
                                # 计算宽高比
                                aspect_ratio = img_h / img_w
                                
                                # 确定是按宽度还是高度缩放
                                if aspect_ratio * max_width <= max_height:
                                    # 宽度优先 - 图片较宽
                                    width = max_width
                                    height = width * aspect_ratio
                                else:
                                    # 高度优先 - 图片较高
                                    height = max_height
                                    width = height / aspect_ratio
                                
                                # 按计算出的宽高创建图片
                                img = Image(img_path, width=width, height=height)
                                
                                # 打印调试信息
                                print(f"图片尺寸: 原始:{img_w}x{img_h}, 比例:{aspect_ratio:.2f}, PDF中:{width:.1f}x{height:.1f}")
                                
                                img_objs.append(img)
                            except Exception as e:
                                print(f"处理图片失败: {str(e)}")
                        
                        # 最多取前4张图片
                        img_objs = img_objs[:4]
                        
                        # 如果找到图片，创建2x2布局的表格
                        if img_objs:
                            # 如果不足4张，用空白填充
                            while len(img_objs) < 4:
                                img_objs.append('')
                            
                            # 创建2行2列的表格
                            rows = []
                            rows.append(img_objs[:2])  # 第一行2张
                            rows.append(img_objs[2:4]) # 第二行2张
                            
                            # 创建表格并添加到PDF元素中
                            table = Table(rows)
                            table.setStyle(TableStyle([
                                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                                ('LEFTPADDING', (0, 0), (-1, -1), 5),
                                ('RIGHTPADDING', (0, 0), (-1, -1), 5),
                                ('TOPPADDING', (0, 0), (-1, -1), 5),
                                ('BOTTOMPADDING', (0, 0), (-1, -1), 5),
                            ]))
                            elements.append(table)
                            elements.append(Spacer(1, 0.2 * inch))
                    else:
                        # 未找到图片时添加明显标记
                        elements.append(Paragraph(f"【警告：未找到匹配图片】", ParagraphStyle(
                            name='WarningStyle',
                            fontName=font_name,
                            fontSize=12,
                            leading=14,
                            textColor=colors.red,
                            encoding='utf-8'
                        )))
                        elements.append(Paragraph(f"提示词索引: {prompt_idx}, 场次: {current_scene}, 集数: {current_episode}", ParagraphStyle(
                            name='WarningDetailStyle',
                            fontName=font_name,
                            fontSize=10,
                            leading=12,
                            textColor=colors.grey,
                            encoding='utf-8'
                        )))
                        
                        # 添加详细信息，帮助用户排查问题
                        if image_dir and os.path.exists(image_dir):
                            elements.append(Paragraph(f"预期图片路径格式: 第{current_episode}集_场次{current_scene}_{prompt_idx}_img*.png", ParagraphStyle(
                                name='WarningExplanation',
                                fontName=font_name,
                                fontSize=8,
                                leading=12,
                                textColor=colors.grey,
                                encoding='utf-8'
                            )))
                            
                            # 检查当前场景是否有其他图片
                            scene_pattern = f"第{current_episode}集_场次{current_scene}_"
                            other_images = []
                            for filename in os.listdir(image_dir):
                                if filename.startswith(scene_pattern) and filename.endswith(".png"):
                                    other_images.append(filename)
                            
                            if other_images:
                                elements.append(Paragraph(f"当前场景的可用图片: {', '.join(other_images[:5])}{' ...' if len(other_images) > 5 else ''}", ParagraphStyle(
                                    name='AvailableImages',
                                    fontName=font_name,
                                    fontSize=8,
                                    leading=12,
                                    textColor=colors.grey,
                                    encoding='utf-8'
                                )))
                        
                        # 添加空间
                        elements.append(Spacer(1, 0.5 * inch))
            i += 1
            continue
        
        # 正常文本内容
        elif not line.startswith('#'):  # 排除提示词
            # 检查是否包含Markdown标记，首先检查粗体
            has_bold = '**' in line or '__' in line
            has_markdown = has_bold or any(md_char in line for md_char in ['*', '_', '`', '[', '##', '-', '1.', '>'])
            
            # 解析Markdown格式
            if has_markdown:
                # 检查特殊格式
                if line.startswith('##'):  # 二级标题
                    clean_line = line.replace('##', '').strip()
                    # 处理可能存在的粗体标记
                    if '**' in clean_line:
                        clean_line = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', clean_line)
                    elements.append(Paragraph(clean_line, styles['ChineseHeading']))
                elif line.startswith('#') and not line.startswith('##'):  # 一级标题
                    clean_line = line.replace('#', '').strip()
                    # 处理可能存在的粗体标记
                    if '**' in clean_line:
                        clean_line = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', clean_line)
                    elements.append(Paragraph(clean_line, styles['ChineseTitle']))
                elif line.strip().startswith('- ') or line.strip().startswith('* '):  # 无序列表
                    # 处理列表项
                    clean_line = line.strip()[2:].strip()
                    # 处理可能存在的粗体标记
                    if '**' in clean_line:
                        clean_line = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', clean_line)
                    elements.append(Paragraph(f"• {clean_line}", styles['ChineseListItem']))
                elif re.match(r'^\d+\.\s', line.strip()):  # 有序列表
                    # 提取编号和内容
                    match = re.match(r'^(\d+)\.(\s.*)', line.strip())
                    if match:
                        num, content = match.groups()
                        content = content.strip()
                        # 处理可能存在的粗体标记
                        if '**' in content:
                            content = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', content)
                        elements.append(Paragraph(f"{num}. {content}", styles['ChineseListItem']))
                elif line.startswith('> '):  # 引用
                    # 处理引用
                    clean_line = line[2:].strip()
                    # 处理可能存在的粗体标记
                    if '**' in clean_line:
                        clean_line = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', clean_line)
                    elements.append(Paragraph(clean_line, ParagraphStyle(
                        name='ChineseQuote',
                        fontName=font_name,
                        fontSize=10,
                        leading=14,
                        leftIndent=20,
                        textColor=colors.darkgrey,
                        encoding='utf-8'
                    )))
                elif '[' in line and '](' in line:  # 处理链接
                    # 将Markdown链接转换为HTML链接
                    clean_line = re.sub(r'\[(.*?)\]\((.*?)\)', r'<a href="\2">\1</a>', line)
                    # 处理可能存在的粗体标记
                    if '**' in clean_line:
                        clean_line = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', clean_line)
                    elements.append(Paragraph(clean_line, styles['ChineseLink']))
                elif has_bold:  # 粗体 - 放在前面以确保优先处理
                    # 替换Markdown粗体标记
                    clean_line = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', line)
                    clean_line = re.sub(r'__(.*?)__', r'<b>\1</b>', clean_line)
                    # 检查是否还有其他格式需要处理
                    if '*' in clean_line and not '**' in clean_line:  # 斜体
                        clean_line = re.sub(r'\*(.*?)\*', r'<i>\1</i>', clean_line)
                    if '_' in clean_line and not '__' in clean_line:  # 斜体
                        clean_line = re.sub(r'_(.*?)_', r'<i>\1</i>', clean_line)
                    if '`' in clean_line:  # 代码
                        clean_line = re.sub(r'`(.*?)`', r'<code>\1</code>', clean_line)
                    elements.append(Paragraph(clean_line, styles['ChineseNormal']))
                elif '*' in line or '_' in line:  # 斜体
                    # 替换Markdown斜体标记
                    clean_line = re.sub(r'\*(.*?)\*', r'<i>\1</i>', line)
                    clean_line = re.sub(r'_(.*?)_', r'<i>\1</i>', clean_line)
                    elements.append(Paragraph(clean_line, styles['ChineseNormal']))
                elif '`' in line:  # 代码
                    # 处理行内代码
                    clean_line = re.sub(r'`(.*?)`', r'<code>\1</code>', line)
                    elements.append(Paragraph(clean_line, styles['ChineseNormal']))
                else:
                    # 其他Markdown格式，使用解析器处理
                    html_content = parse_markdown(line)
                    elements.append(Paragraph(html_content, styles['ChineseNormal']))
            else:
                # 检查是否是结束标记"(完)"或"第X集(完)"
                if line.strip() == "(完)" or re.search(r'第\d+集\s*\(完\)', line.strip()):
                    print(f"检测到剧本结束标记: {line.strip()}")
                    elements.append(Paragraph(line, styles['ChineseNormal']))
                    
                    # 判断是整部剧结束还是当前集结束
                    if current_episode and re.search(r'第' + re.escape(current_episode) + r'集\s*\(完\)', line.strip()):
                        print(f"检测到第{current_episode}集结束，等待下一集开始")
                        skip_until_next_episode = True
                        # 在设置跳过标记后，清空当前场景和提示词信息，避免重复处理
                        current_scene = None
                        processed_prompts = set()  # 清空已处理提示词记录
                    elif line.strip() == "(完)" and i > 0 and i+1 < len(lines):
                        # 查看前后文，判断是否是集结束而非整部剧结束
                        prev_lines = "\n".join(lines[max(0, i-10):i])
                        next_lines = "\n".join(lines[i+1:min(len(lines), i+20)])
                        
                        # 如果前文有当前集信息且后文有新集信息，则认为是当前集结束
                        if (current_episode and f"第{current_episode}集" in prev_lines) and re.search(r'第\s*\d+\s*集', next_lines):
                            print(f"从上下文判断第{current_episode}集结束，等待下一集开始")
                            skip_until_next_episode = True
                            # 在设置跳过标记后，清空当前场景和提示词信息，避免重复处理
                            current_scene = None
                            processed_prompts = set()  # 清空已处理提示词记录
                        else:
                            print("检测到整部剧本结束标记")
                    
                    i += 1
                    continue
                
                elements.append(Paragraph(line, styles['ChineseNormal']))
            i += 1
            continue
        else:
            # 其他未分类的文本
            # 处理可能存在的粗体标记
            if '**' in line:
                line = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', line)
            
            # 检查是否是结束标记"(完)"或"第X集(完)"
            if line.strip() == "(完)" or re.search(r'第\d+集\s*\(完\)', line.strip()):
                print(f"检测到剧本结束标记: {line.strip()}")
                elements.append(Paragraph(line, styles['ChineseNormal']))
                
                # 判断是整部剧结束还是当前集结束
                if current_episode and re.search(r'第' + re.escape(current_episode) + r'集\s*\(完\)', line.strip()):
                    print(f"检测到第{current_episode}集结束，等待下一集开始")
                    skip_until_next_episode = True
                    # 在设置跳过标记后，清空当前场景和提示词信息，避免重复处理
                    current_scene = None
                    processed_prompts = set()  # 清空已处理提示词记录
                elif line.strip() == "(完)" and i > 0 and i+1 < len(lines):
                    # 查看前后文，判断是否是集结束而非整部剧结束
                    prev_lines = "\n".join(lines[max(0, i-10):i])
                    next_lines = "\n".join(lines[i+1:min(len(lines), i+20)])
                    
                    # 如果前文有当前集信息且后文有新集信息，则认为是当前集结束
                    if (current_episode and f"第{current_episode}集" in prev_lines) and re.search(r'第\s*\d+\s*集', next_lines):
                        print(f"从上下文判断第{current_episode}集结束，等待下一集开始")
                        skip_until_next_episode = True
                        # 在设置跳过标记后，清空当前场景和提示词信息，避免重复处理
                        current_scene = None
                        processed_prompts = set()  # 清空已处理提示词记录
                    else:
                        print("检测到整部剧本结束标记")
                
                i += 1
                continue
            
            elements.append(Paragraph(line, styles['ChineseNormal']))
            i += 1
    
    # 处理完成后添加汇总信息
    if processed_episodes:
        print(f"已处理的集数: {sorted(list(processed_episodes))}")
        if all_episodes - processed_episodes:
            print(f"警告: 以下集数可能未被处理: {sorted(list(all_episodes - processed_episodes))}")
    else:
        print("警告: 未处理任何明确的集数")
    
    # 在开始处添加目录
    if toc_entries:
        toc_elements = []
        # 添加标题页
        toc_elements.append(Paragraph(f"{title} - 剧本与场景图", styles['ChineseTitle']))
        toc_elements.append(Spacer(1, 0.25 * inch))
        
        # 添加目录标题
        toc_elements.append(Paragraph("目录", styles['TOC_Title']))
        toc_elements.append(Spacer(1, 0.1 * inch))
        
        # 分类整理目录项
        episodes = {}
        for item_type, entry, page_num in toc_entries:
            if item_type == "episode":
                episodes[entry] = []
            elif item_type == "scene" and episodes:
                # 添加到最后一个集的场次列表
                last_episode = list(episodes.keys())[-1]
                episodes[last_episode].append((entry, page_num))
        
        # 为每个目录项生成带有点线的段落
        for episode, scenes in episodes.items():
            # 添加集标题
            toc_elements.append(Paragraph(episode, styles['TOC_Section']))
            
            # 添加该集的场次
            for scene, page_num in scenes:
                # 创建带有点线和页码的条目
                entry_text = f'{scene} {"." * 40} {page_num}'
                toc_elements.append(Paragraph(entry_text, styles['TOC_Entry']))
        
        # 添加分页符
        toc_elements.append(PageBreak())
        
        # 将目录元素插入到elements列表的开头
        # 由于toc_elements中已包含标题页内容，移除elements中的重复内容
        elements = toc_elements + elements[2:]  # 跳过原来的标题和空白
    
    # 构建PDF
    doc.build(elements)
    
    # 如果没有指定输出路径，返回PDF字节数据
    if output_path is None:
        buffer.seek(0)
        return buffer.getvalue()
    else:
        return None


async def create_script_pdf(
    task_id: str, 
    script_content: str, 
    image_data: Dict[str, Dict[str, Dict[str, Dict[str, Any]]]], 
    output_dir: str = None,
    filename: str = None
) -> str:
    """
    创建剧本PDF文件并保存
    
    Args:
        task_id: 任务ID
        script_content: 剧本内容
        image_data: 图片数据字典，格式为 {episode: {scene: {prompt_idx: {...}}}}
        output_dir: 输出目录
        filename: 自定义文件名（可选）
        
    Returns:
        str: 生成的PDF文件路径
    """
    # 确保输出目录存在
    if output_dir is None:
        output_dir = os.path.join("app", "storage", "pdfs")
        
    os.makedirs(output_dir, exist_ok=True)
    
    # 如果没有提供自定义文件名，则使用默认命名规则
    if not filename:
        # 提取剧名
        title_match = re.search(r'剧名：《(.+?)》', script_content)
        title = title_match.group(1) if title_match else "未命名剧本"
        
        # 设置PDF文件名
        filename = f"{title}_{task_id}.pdf"
    
    # 构建完整路径
    output_path = os.path.join(output_dir, filename)
    
    # 如果文件已经存在，直接返回路径
    if os.path.exists(output_path):
        print(f"PDF文件已经存在，直接返回路径: {output_path}")
        return output_path
    
    # 打印调试信息
    print(f"准备生成PDF: {output_path}")
    print(f"任务ID: {task_id}")
    print(f"剧本长度: {len(script_content)} 字符")
    print(f"图片数据集数: {len(image_data) if image_data else 0}")
    
    # 检查图片目录是否存在
    image_dir = os.path.join("app", "storage", "images", task_id)
    if os.path.exists(image_dir):
        print(f"图片目录存在: {image_dir}")
        # 列出目录中的图片数量
        image_files = [f for f in os.listdir(image_dir) if f.endswith('.png')]
        print(f"图片目录中的图片数量: {len(image_files)}")
        if len(image_files) > 0:
            print(f"示例图片: {', '.join(image_files[:3])}")
    else:
        print(f"警告: 图片目录不存在: {image_dir}")
    
    # 生成PDF
    try:
        # 确保传递task_id参数，用于查找本地图片
        await generate_script_pdf(
            script_content=script_content,
            image_data=image_data,
            output_path=output_path,
            task_id=task_id  # 确保传递task_id
        )
        print(f"PDF生成成功: {output_path}")
        return output_path
    except Exception as e:
        print(f"PDF生成失败: {str(e)}")
        # 记录更详细的错误信息
        import traceback
        error_details = traceback.format_exc()
        print(error_details)
        
        raise
    finally:
        # 如果生成失败且生成了部分文件，清理它
        if 'e' in locals() and os.path.exists(output_path):
            try:
                os.remove(output_path)
                print(f"已删除部分生成的PDF文件: {output_path}")
            except Exception as cleanup_error:
                print(f"清理部分生成的PDF文件失败: {str(cleanup_error)}") 